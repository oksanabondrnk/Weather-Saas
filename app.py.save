from flask import Flask, request, jsonify 
from datetime import datetime, timezone
import requests
import os

app = Flask(__name__)

SECURITY_TOKEN      = os.getenv("SECURITY_TOKEN", "5db521YSKoOVRIBOFU0iO7UftO9SZJ4gotKiEYMVw5Q")
VISUAL_CROSSING_KEY = os.getenv("VISUAL_CROSSING_KEY", "SJ6HN4JENTRLP94HCPPVUPJBC")
ANTHROPIC_KEY       = os.getenv("ANTHROPIC_KEY", "")       


def validate_request(data: dict):
    """Return an error string if the request payload is invalid, else None."""
    required = ["token", "requester_name", "location", "date"]
    for field in required:
        if field not in data:
            return f"Missing required field: '{field}'"
    if data["token"] != SECURITY_TOKEN:
        return "Invalid security token"
    try:
        datetime.strptime(data["date"], "%Y-%m-%d")
    except ValueError:
        return "Field 'date' must be in YYYY-MM-DD format"
    return None


def fetch_weather(location: str, date: str) -> dict:
    """Call Visual Crossing and return a clean weather dict."""
    url = (
        f"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/"
        f"timeline/{requests.utils.quote(location)}/{date}/{date}"
    )
    params = {
        "unitGroup": "metric",
        "key": VISUAL_CROSSING_KEY,
        "contentType": "json",
        "include": "hours,days",
    }
    resp = requests.get(url, params=params, timeout=10)
    resp.raise_for_status()
    raw = resp.json()

    day = raw["days"][0]

    # Build hourly summary
    hours = []
    for h in day.get("hours", []):
        hours.append({
            "time":        h.get("datetime"),
            "temp_c":      h.get("temp"),
            "feels_like_c":h.get("feelslike"),
            "wind_kph":    h.get("windspeed"),
            "wind_dir":    h.get("winddir"),
            "pressure_mb": h.get("pressure"),
            "humidity":    h.get("humidity"),
            "precip_mm":   h.get("precip"),
            "cloud_cover": h.get("cloudcover"),
            "visibility_km":h.get("visibility"),
            "uv_index":    h.get("uvindex"),
            "conditions":  h.get("conditions"),
        })

    return {
        "temp_c":          day.get("temp"),
        "temp_max_c":      day.get("tempmax"),
        "temp_min_c":      day.get("tempmin"),
        "feels_like_c":    day.get("feelslike"),
        "wind_kph":        day.get("windspeed"),
        "wind_gust_kph":   day.get("windgust"),
        "wind_dir_deg":    day.get("winddir"),
        "pressure_mb":     day.get("pressure"),
        "humidity":        day.get("humidity"),
        "precip_mm":       day.get("precip"),
        "precip_prob":     day.get("precipprob"),
        "snow_cm":         day.get("snow"),
        "cloud_cover":     day.get("cloudcover"),
        "visibility_km":   day.get("visibility"),
        "uv_index":        day.get("uvindex"),
        "sunrise":         day.get("sunrise"),
        "sunset":          day.get("sunset"),
        "conditions":      day.get("conditions"),
        "description":     day.get("description"),
        "hourly":          hours,
    }


def ask_claude(weather: dict, location: str, date: str) -> str:
    """Call Claude API to get AI-powered weather recommendations."""
    if not ANTHROPIC_KEY:
        return "AI recommendations unavailable (no API key configured)."

    prompt = f"""
You are a helpful weather assistant. Based on the following weather data for {location} on {date},
provide practical recommendations including:
1. What to wear
2. Best time windows for outdoor activities
3. UAV/drone flight suitability (best altitude window, time of day, any warnings)
4. Any other useful tips for the day

Weather data:
- Average temperature: {weather['temp_c']}°C (max {weather['temp_max_c']}°C, min {weather['temp_min_c']}°C)
- Wind speed: {weather['wind_kph']} kph (gusts up to {weather['wind_gust_kph']} kph)
- Humidity: {weather['humidity']}%
- Precipitation probability: {weather['precip_prob']}%
- Cloud cover: {weather['cloud_cover']}%
- Conditions: {weather['conditions']}
- Description: {weather['description']}

Keep your response concise and structured with clear sections.
"""

    headers = {
        "x-api-key": ANTHROPIC_KEY,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
    }
    body = {
        "model": "claude-haiku-4-5-20251001",
        "max_tokens": 600,
        "messages": [{"role": "user", "content": prompt}],
    }
    resp = requests.post(
        "https://api.anthropic.com/v1/messages",
        headers=headers,
        json=body,
        timeout=30,
    )
    resp.raise_for_status()
    return resp.json()["content"][0]["text"]


@app.route("/health", methods=["GET"])
def health():
    """Simple health-check endpoint."""
    return jsonify({"status": "ok", "timestamp": datetime.now(timezone.utc).isoformat()})


@app.route("/weather", methods=["POST"])
def weather():
    """
    Main weather endpoint.

    Expected JSON body:
        token          – security token
        requester_name – full name
        location       – e.g. "Kyiv,Ukraine"
        date           – YYYY-MM-DD
    """
    data = request.get_json(silent=True)
    if not data:
        return jsonify({"error": "Request body must be valid JSON"}), 400

    err = validate_request(data)
    if err:
        return jsonify({"error": err}), 401 if "token" in err.lower() else 400

    try:
        weather_data = fetch_weather(data["location"], data["date"])
    except requests.HTTPError as e:
        status = e.response.status_code if e.response else 502
        return jsonify({"error": f"Weather API error: {e}"}), status
    except requests.RequestException as e:
        return jsonify({"error": f"Failed to reach weather service: {e}"}), 502

    return jsonify({
        "requester_name": data["requester_name"],
        "timestamp":      datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
        "location":       data["location"],
        "date":           data["date"],
        "weather":        weather_data,
    })


@app.route("/weather/ai", methods=["POST"])
def weather_ai():
    """
    Extended endpoint that returns weather + Claude AI recommendations.

    Same payload as /weather.
    """
    data = request.get_json(silent=True)
    if not data:
        return jsonify({"error": "Request body must be valid JSON"}), 400

    err = validate_request(data)
    if err:
        return jsonify({"error": err}), 401 if "token" in err.lower() else 400

    try:
        weather_data = fetch_weather(data["location"], data["date"])
    except requests.HTTPError as e:
        status = e.response.status_code if e.response else 502
        return jsonify({"error": f"Weather API error: {e}"}), status
    except requests.RequestException as e:
        return jsonify({"error": f"Failed to reach weather service: {e}"}), 502

    ai_advice = ask_claude(weather_data, data["location"], data["date"])

    return jsonify({
        "requester_name":    data["requester_name"],
        "timestamp":         datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
        "location":          data["location"],
        "date":              data["date"],
        "weather":           weather_data,
        "ai_recommendations": ai_advice,
    })



if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=False)
